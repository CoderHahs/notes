---
title: 'Blackbox Testing'
metaTitle: 'Blackbox Testing'
metaDescription: 'Software QA - Blackbox Testing'
---

Black-box testing is testing without having an insight into the details of underlying code.

# Error Guessing

## Approach

1. Make a list of possible errors or error-prone situations

- Error model

2. Design test-cases to cover error model

### Advantages:

- effective complement of other techniques
- quick and efficient
- can be actively developed skill through time

### Disadvantages:

- quality of tests depend on the tester's experience
- metrics about test sufficiency can not be gathered
- not available to in-experience users

# Equivalence Partitioning

It is a software testing technique, like a black box technique.

The roles:

- it divides the input data of software into different equivalence data classes
- you can apply this technique where there is a range in the input field
- test each partition once

For example if you have some input field where the only possible inputs are numbers between 1 and 10, then your Equivalence Partition Classes would be:

- Valid: Any number between 1-10
- Invalid: Any number <= 0, and any number >= 10

## Myer's Selection Approach

1. Until all valid ECs have been covered by test cases, write a new test cases that covers as many of the uncovered valid ECs as possible
2. Until all invalid ECs have been covered by test cases, write a test case that covers _one, and only one_ of the uncovered invalid ECs

# Boundary Value Analysis:

Valid partitions have 2 more test cases, the min+1 and max+1

For the above example, our ECs are now:

- Valid: 1, 2, 9, 10
- Invalid: 0, 11

In this case we test the values at the boundaries.

# Category Partitioning

Steps: For each functional units:

1. identify parameters and environment conditions
2. identify categories for each parameter/condition
3. partition each Category in _choices_
4. add constraints to choices
5. create _test frames_ as selection of choices
6. create _test cases_ from _test frames_

# Cause-effect graphing

A systematic way to aid selecting a set of test cases

to identify/analyze relationships in a decision table
– generate boolean formula

Nodes:
- Cause - distinct instance of input condition or EC
- Effect - observable result of change in system state
- Intermediate node - combination of causes representing an expression on input conditions

## Test generation from Cause-Effect graphs
- Divide the specification into workable pieces.
- Define separate graphs for each piece.
1. Identify Causes and Effects
2. Deduce Logical Relationships and Constraints - represent as graph
3. Draw a decision table
4. Convert each variant in the decision table into a test
case.

## Test generation from Cause-Effect graphs
- To find the unique combination of conditions
- Work with a single effect (output) at a time
1. Set effect to true (1) state
2. Look backward for all combination of inputs which will
force effect to the true state (constraints limit number of
combination)
3. Create a column in decision table for each combination
4. Determine states of all other effects for each combination

## Boolean Formula Generation from Cause-Effect graphs
- Working from effects toward causes
1. Transcribe node-to-node formulas from the graph
    – write formula for each effect and its predecessors
    – For each intermediate node
        - write formula for intermediate node and its predecessors
2. Derive the complete Boolean formula
– replace intermediate variables by substitution until the effect
formula contains only cause variables
- factor and rewrite formula into sum-of-products form

## Each-Condition/All-Conditions
- Method to create Decision Table from Boolean Formula
- Set of variants includes
– For each variable, a variant such that the variable is made
true with all other variables being false, and
    - One variant such that all variables are true (and logic), or
    - One variant such that all variables are false (or logic)