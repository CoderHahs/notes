---
title: "Graph Algorithms"
metaTitle: "Graph Algorithms"
metaDescription: "Topics in Graph Algorithms"
---
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css"
  integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG"
  crossOrigin="anonymous"
/>

For an intro to graphs refer to this [page](https://hrithiks-notes.netlify.app/discrete_structures/10_graph_theory) for more details.

# Exploring Undirected Graph

Let $G = (V, E)$ be an undirected graph.

Task: Find all vertices that can be reached from a given vertex $v \in V$.

```python
def explore(v):
    visited(v) = True
    previsit(v) # see later
    for each edge {u,v} in E do:
        if visited(u) = False:
            call explore(u)
    postvisit(v) # see later
```

The number of vertices u such that “visited(u) = false” decreases in each recursive call. Since there is a finite number of vertices, the algorithm eventually terminates.

## Lemma

Assume that, initially, *visited(u)* = False. After explore(v) has terminated, *visited(u)* = True $\iff$ there is a path from $v$ to $u$.

## Connected Components of G = (V, E)

```python
def DFS (G):
  for all v in V do:
    visited (v) = false
  cc = 0
  for all v in V do:
    if visited (v) = false:
      cc = cc + 1
      explore (v)
```

### Run-time of DFS

First for-loop: $O(|V|)$ time

Second for-loop:
- ```explore(u)``` is called exactly once for each vertex u (this may be a recursive call)
- time spent for ```explore(u)```, excluding recursive calls is $O(1 + degree(u))$

Total time: $O (|V| + \sum_{u \in V}(1+ \mathrm{degree}(u))) = O(|V| + |V| + 2|E|) = O(|V| + |E|)$

# Directed Graphs

Assume that $G = (V,E)$ is directed and acyclic. 

Topological Sorting or Ordering is the numbering the vertices $1, 2, ... , n$ such that for each edge (u,v), $#(u) < #(v)$

```python
def TopologicalOrdering(G):
  # Input: a directed acyclic graph G (V, E)
  # Output: A topological ordering of V
  k = 1
  while V != {} do:
    Choose a vertex u in V with indegree 0
    Give u the number k
    k = k + 1
    Remove u from G
```

## Prenumbers and Postnumbers

Let $G = (V, E)$ be a directed graph. For each vertex $v \in V$, we define the following two numbers with respect to Depth-First-Search. 

- **pre(v)**: the first time we visit $v$ (the time at which *explore(v)* is called)
- **post(v)**: the time at which *explore(v)* is finished.

Use variable *clock*. At start, clock = 1.

```python
def previsit(v):
  pre(v) = clock
  clock += 1
def postvisit(v):
  post(v) = clock
  clock += 1
```

## 4 Types of Edges

### Tree edge

- edge $v \rightarrow u$
- $explore(u)$ is called as a recursive call within $explore(v)$
- solid edge
- literally the edges we follow when we execute DFS

### Forward edge
- edge $v \rightarrow u$ where in the (solid) tree,
- $u$ is in subtree of $v$
- $u$ is not a child of $v$
- shortcut that brings you down the tree

### Back edge
- edge $v \rightarrow u$ where in the (solid) tree,
- $v$ in subtree of $u$
- enable you to go back in the tree

### Cross edge
- lets you go from one subtree to another
- all other edges

## Acyclic vs Cyclic

$G$ has a directed cycle if and only if DFS-forest has a back-edge.

### How to test if a directed graph is cyclic?

1. Run DFS (including pre/post-numbers)
2. For each non-tree edge(v, u), test if *pre(u) < pre(v) > post(v) < post(u)*
  - if "yes" fpr at least one non-tree edge, return "cyclic"
  - if "no" for all non-tree edges, return "acyclic"

Running time: *O(|V| + |E|)*

### Topological Sort for directed acyclic graph

1. Run DFS (including pre/post-numbers)
2. Run Bucket Sort to sort the vertices by post-number.
3. Obtain the topological ordering from the reverse sorted order of the post-numbers.

# Shortest Paths

